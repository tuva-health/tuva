<!DOCTYPE html>
<!-- 
LOCAL DEVELOPMENT TOOL ONLY
This page is for quick local visualization of aggregated, non-PHI metrics
exported from your warehouse (CSV). Do not deploy publicly.
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tuva Terminology Metrics</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1f2937; margin: 0; padding: 24px; }
    .container { max-width: 1600px; margin: 0 auto; background: #fff; border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,0.08); overflow: hidden; }
    .header { background: linear-gradient(135deg, #2563eb 0%, #1e3a8a 100%); color: #fff; padding: 32px 40px; display: flex; align-items: center; gap: 16px; }
    .header img { height: 32px; }
    .header h1 { font-size: 1.8rem; margin: 0; }
    .content { padding: 20px 24px 30px; }
    .upload { border: 2px dashed #cbd5e1; border-radius: 12px; padding: 24px; text-align: center; cursor: pointer; transition: all 0.2s ease; }
    .upload:hover { border-color: #2563eb; background: #eff6ff; }
    .upload.dragover { border-color: #1d4ed8; background: #dbeafe; }
    .controls { display: flex; gap: 12px; margin: 20px 0; flex-wrap: wrap; align-items: center; }
    select, button { padding: 10px 12px; border: 1px solid #cbd5e1; border-radius: 8px; background: #fff; }
    button.primary { background: #2563eb; color: #fff; border: none; }
    .table { width: 100%; border-collapse: collapse; }
    .table th, .table td { text-align: left; padding: 10px 8px; border-bottom: 1px solid #e5e7eb; font-size: 0.95rem; }
    .table th { font-weight: 600; color: #374151; background: #f9fafb; position: sticky; top: 0; z-index: 1; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 9999px; font-size: 0.8rem; font-weight: 600; }
    .badge.pass { background: #dcfce7; color: #166534; }
    .badge.fail { background: #fee2e2; color: #991b1b; }
    .percent-bar { background: #e5e7eb; height: 10px; border-radius: 9999px; overflow: hidden; }
    .percent-fill { height: 100%; background: #16a34a; }
    .percent-text { font-weight: 600; color: #111827; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 24px; }
    .footer { margin-top: 24px; color: #6b7280; font-size: 0.85rem; text-align: center; }
    .sql { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; background:#0b1020; color:#d1e7ff; padding:12px; border-radius:8px; font-size:0.85rem; white-space:pre-wrap; }
    .small { font-size: 0.85rem; color:#6b7280; }
    .error { background:#fee2e2; border:1px solid #ef4444; color:#991b1b; padding:12px 14px; border-radius:8px; }
    .info { background:#eff6ff; border:1px solid #3b82f6; color:#1e40af; padding:12px 14px; border-radius:8px; }
    .sortable { cursor: pointer; user-select: none; }
    .sort-indicator { color:#64748b; font-size:0.9em; margin-left:4px; }
    .group-row { background:#f3f4f6; font-weight:600; }
    .subgroup-row { background:#f9fafb; font-weight:600; }
    .caret { display:inline-block; width:1em; color:#6b7280; }
    /* Modal styles */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.45); display: none; align-items: center; justify-content: center; z-index: 50; padding: 16px; }
    .modal { background: #fff; border-radius: 12px; box-shadow: 0 12px 40px rgba(0,0,0,0.25); width: min(980px, 95vw); max-height: 85vh; display: flex; flex-direction: column; overflow: hidden; }
    .modal-header { padding: 14px 16px; border-bottom: 1px solid #e5e7eb; display:flex; align-items:center; justify-content: space-between; }
    .modal-title { font-weight: 600; }
    .modal-close { background: transparent; border: none; font-size: 20px; cursor: pointer; color:#374151; }
    .modal-body { padding: 16px; overflow: auto; }
    .btn { padding: 8px 10px; border: 1px solid #cbd5e1; border-radius: 8px; background: #fff; cursor: pointer; }
    .btn.primary { background: #2563eb; color: #fff; border: none; }
    .subtle { color:#64748b; }
    /* Anchored popover for value lists */
    .popover { position: fixed; z-index: 60; background: #fff; border: 1px solid #e5e7eb; box-shadow: 0 10px 30px rgba(0,0,0,0.18); border-radius: 10px; width: 460px; max-width: 90vw; max-height: 60vh; overflow: hidden; display: none; }
    .popover-header { padding: 10px 12px; border-bottom: 1px solid #e5e7eb; font-weight: 600; display:flex; align-items:center; justify-content: space-between; }
    .popover-body { padding: 10px; overflow: auto; }
    .popover-close { background: transparent; border: none; cursor: pointer; font-size: 18px; color:#6b7280; }
  </style>
  <script>
    let metrics = [];
    let filtered = [];
    let byDataSource = new Map();
    // preloaded details index for offender values
    let detailsIdx = new Map();
    let sortKey = 'valid_pct';
    let sortAsc = true; // ascending by default
    let viewMode = 'table';
    const collapsedTop = new Set();
    const collapsedSub = new Set();
    let valuePopover = null;
    let valuePopoverAnchor = null;

    function showError(message) {
      const box = byId('errorBox');
      if (!box) return;
      box.className = 'error';
      box.innerText = message;
      box.style.display = '';
      try { showToast('Error: ' + message, 'error'); } catch(e){}
    }

    function showInfo(message) {
      const box = byId('errorBox');
      if (!box) return;
      box.className = 'info';
      box.innerText = message;
      box.style.display = '';
      try { showToast(message, 'info'); } catch(e){}
    }

    function clearError() {
      const box = byId('errorBox');
      if (!box) return;
      box.style.display = 'none';
      box.innerText = '';
    }

    function byId(id) { return document.getElementById(id); }

    function ensurePopover() {
      if (valuePopover) return valuePopover;
      const el = document.createElement('div'); el.id = 'valuePopover'; el.className = 'popover';
      el.innerHTML = `<div class="popover-header"><div id=\"popoverTitle\">Top values</div><button class=\"popover-close\" aria-label=\"Close\" onclick=\"closePopover()\">×</button></div><div class=\"popover-body\" id=\"popoverBody\"></div>`;
      document.body.appendChild(el);
      valuePopover = el;
      document.addEventListener('click', (e) => {
        if (!valuePopover || valuePopover.style.display === 'none') return;
        if (valuePopover.contains(e.target)) return;
        if (valuePopoverAnchor && valuePopoverAnchor.contains(e.target)) return;
        closePopover();
      });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePopover(); });
      window.addEventListener('scroll', () => { if (valuePopover && valuePopover.style.display !== 'none') closePopover(); }, true);
      window.addEventListener('resize', () => { if (valuePopover && valuePopover.style.display !== 'none') closePopover(); });
      return valuePopover;
    }

    function closePopover() {
      if (!valuePopover) return;
      valuePopover.style.display = 'none';
      valuePopoverAnchor = null;
    }

    function positionPopover(anchor) {
      const rect = anchor.getBoundingClientRect();
      const el = ensurePopover();
      const width = Math.min(460, window.innerWidth * 0.9);
      el.style.width = width + 'px';
      const margin = 8;
      // quickly measure height by showing offscreen
      el.style.visibility = 'hidden'; el.style.display = 'block';
      const height = el.offsetHeight || 320; el.style.display = 'none'; el.style.visibility = '';
      let top = rect.bottom + margin;
      let left = rect.left;
      if (top + height > window.innerHeight) {
        top = Math.max(margin, rect.top - height - margin);
      }
      if (left + width > window.innerWidth - margin) left = window.innerWidth - width - margin;
      if (left < margin) left = margin;
      el.style.top = `${top}px`;
      el.style.left = `${left}px`;
    }

    function openValuePopover(anchor, idx, bucket) {
      const ds = (byId('dataSource')?.value||'').trim();
      const row = filtered[idx];
      const tops = getTopValues(ds, row.payer, row.plan, row.metric_id, row.claim_scope, bucket) || [];
      ensurePopover();
      const titleEl = byId('popoverTitle');
      const bodyEl = byId('popoverBody');
      titleEl.textContent = `${row.metric_name || row.metric_id} — Top ${bucket} values`;
      bodyEl.innerHTML = '';
      if (tops.length) {
        const table = document.createElement('table'); table.className = 'table';
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th style=\"width:50%;\">value</th><th>description</th><th style=\"text-align:right;\">count</th></tr>';
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        tops.slice(0, 50).forEach(r => {
          const tr = document.createElement('tr');
          const v = document.createElement('td'); v.textContent = r.value_code || '(blank)'; tr.appendChild(v);
          const d = document.createElement('td'); d.textContent = r.value_desc || ''; tr.appendChild(d);
          const c = document.createElement('td'); c.style.textAlign = 'right'; c.textContent = (r.frequency || 0).toLocaleString(); tr.appendChild(c);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody); bodyEl.appendChild(table);
      } else {
        const msg = document.createElement('div'); msg.className = 'info';
        msg.textContent = `No preloaded ${bucket} values found. Load a details CSV or use the SQL in the row.`;
        bodyEl.appendChild(msg);
      }
      valuePopover.style.display = 'block';
      valuePopoverAnchor = anchor;
      positionPopover(anchor);
    }

    function handleDragOver(e) { e.preventDefault(); byId('drop').classList.add('dragover'); }
    function handleDragLeave(e) { e.preventDefault(); byId('drop').classList.remove('dragover'); }
    function handleDrop(e) {
      e.preventDefault(); byId('drop').classList.remove('dragover');
      const files = Array.from(e.dataTransfer.files || []);
      files.forEach(f => readFile(f));
    }
    function handlePick() { byId('file').click(); }
    function handleFile(e) { const files = Array.from(e.target.files || []); files.forEach(f => readFile(f)); }

    function readFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          // Clear any prior message before attempting to route
          clearError();
          routeCSV(e.target.result);
        } catch (err) {
          console.error(err);
          showError('Error parsing CSV: ' + (err && err.message ? err.message : String(err)));
        }
      };
      reader.readAsText(file);
    }

    function routeCSV(csvText) {
      const lines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim().split('\n');
      if (!lines.length) { showError('Empty file'); return; }
      const headers = parseCSVLine(lines[0]).map(h => h.replace(/\"/g, '"').replace(/"/g, '').trim().toLowerCase());
      const isMetrics = headers.includes('metric_id') && (headers.includes('denominator_n') || headers.includes('valid_n'));
      // Be permissive in recognizing details exports from the warehouse
      const isDetails = headers.includes('bucket_name') || headers.includes('drill_down_value') || (headers.includes('field_value') || headers.includes('value_code') || headers.includes('value'));
      if (isMetrics) { loadMetricsCSV(csvText); return; }
      if (isDetails) { loadDetailsCSV(csvText); return; }
      showError('Unrecognized CSV. Expected metrics or details columns.');
    }

    function loadMetricsCSV(csvText) {
      metrics = parseCSV(csvText).map(canonicalizeRow).filter(r => r.metric_id && r.data_source);
      if (!metrics.length) {
        showError('No rows parsed from CSV. Confirm headers like data_source, metric_id, metric_name, valid_n, denominator_n exist and that the file uses commas as delimiters.');
        return;
      }
      clearError();
      byDataSource = new Map();
      metrics.forEach(m => {
        const key = String(m.data_source || '').trim();
        if (!byDataSource.has(key)) byDataSource.set(key, []);
        byDataSource.get(key).push(m);
      });
      populateDataSourceSelector();
      const currentDs = (byId('dataSource') && byId('dataSource').value) ? byId('dataSource').value : (Array.from(byDataSource.keys())[0] || '');
      populateScopeSelector(currentDs);
      populatePayerPlanSelectors(currentDs);
      updateSortIndicators();
      render();
    }

    function loadDetailsCSV(csvText) {
      const raw = parseCSV(csvText);
      if (!raw.length) { showError('No rows parsed from details CSV'); return; }
      const details = raw.map(canonicalizeDetailsRow).filter(r => r.metric_id && r.data_source && r.bucket_name);
      if (!details.length) {
        showError('Unable to detect required columns for details CSV (need at least data_source, metric_id, bucket_name, and value).');
        return;
      }
      // index by composite key
      detailsIdx = new Map();
      details.forEach(r => {
        const key = `${r.data_source}||${r.payer||''}||${r.plan||''}||${r.metric_id}||${r.claim_scope||''}||${r.bucket_name}`;
        if (!detailsIdx.has(key)) detailsIdx.set(key, []);
        detailsIdx.get(key).push(r);
      });
      for (const arr of detailsIdx.values()) arr.sort((a,b) => b.frequency - a.frequency);
      // Surface a friendly confirmation
      let uniqueBuckets = 0; for (const _ of detailsIdx.keys()) uniqueBuckets++;
      showInfo(`Loaded ${details.length.toLocaleString()} details rows across ${uniqueBuckets.toLocaleString()} metric buckets.`);
    }

    function parseCSV(csvText) {
      const lines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim().split('\n');
      if (!lines.length) return [];
      const headers = parseCSVLine(lines[0]).map(h => h.replace(/\"/g, '"').replace(/"/g, '').trim());
      const rows = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i]; if (!line.trim()) continue;
        const values = parseCSVLine(line).map(v => v.replace(/\"/g, '"').replace(/"/g, '').trim());
        const row = {};
        headers.forEach((h, idx) => row[h] = values[idx] ?? '');
        rows.push(row);
      }
      return rows;
    }

    function canonicalizeDetailsRow(row) {
      const get = (keys, def='') => {
        for (const k of keys) {
          for (const variant of [k, k.toLowerCase(), k.toUpperCase()]) {
            if (row.hasOwnProperty(variant)) return row[variant];
          }
        }
        return def;
      };
      const num = v => { if (v === null || v === undefined || v === '') return NaN; const n = Number(String(v).replace(/,/g,'')); return isNaN(n) ? NaN : n; };
      const fv = get(['value_code','field_value','value','drill_down_value','drill_down_code']);
      let code = fv, desc = '';
      if (typeof fv === 'string' && fv.includes('|')) {
        const parts = fv.split('|'); code = parts[0].trim(); desc = (parts[1]||'').trim();
      }
      const claimScopeRaw = get(['claim_scope','scope','claim_type']);
      const claimScope = String(claimScopeRaw || '').trim().toLowerCase();
      // try to build metric_id if missing
      const fieldName = get(['field_name','field','metric_field','dimension']);
      let metricId = get(['metric_id','metric']);
      // normalize an existing metric_id (claims:<scope>:<FIELD>)
      if (metricId && typeof metricId === 'string' && metricId.startsWith('claims:')) {
        const parts = metricId.split(':');
        if (parts.length === 3) {
          parts[1] = String(parts[1] || '').toLowerCase();
          parts[2] = String(parts[2] || '').toUpperCase();
          metricId = parts.join(':');
        }
      }
      if (!metricId && claimScope && fieldName) {
        metricId = `claims:${claimScope}:${String(fieldName).trim().toUpperCase()}`;
      }
      // choose frequency: use provided numeric, else default to 1 when a value is present
      let freq = num(get(['frequency','count','freq','offender_rows','rows'], ''));
      if (isNaN(freq)) freq = fv ? 1 : 0;
      return {
        data_source: get(['data_source','datasource']),
        payer: get(['payer']),
        plan: get(['plan']),
        metric_id: metricId,
        claim_scope: claimScope,
        bucket_name: String(get(['bucket_name','bucket'])).trim().toLowerCase(),
        value_code: code,
        value_desc: get(['value_desc','description','drill_down_desc','desc'], desc),
        frequency: freq
      };
    }

    function canonicalizeRow(row) {
      const get = (keys, def='') => {
        for (const k of keys) {
          for (const variant of [k, k.toLowerCase(), k.toUpperCase()]) {
            if (row.hasOwnProperty(variant)) return row[variant];
          }
        }
        return def;
      };
      const num = (v) => {
        if (v === null || v === undefined || v === '') return 0;
        const s = String(v).replace(/,/g,'').trim();
        const n = Number(s); return isNaN(n) ? 0 : n;
      };
      const pct = (v) => {
        if (v === null || v === undefined || v === '') return null;
        const s = String(v).replace(/,/g,'').trim();
        const n = Number(s); return isNaN(n) ? null : n;
      };
      const out = {
        data_source: get(['data_source','datasource']),
        payer: get(['payer']),
        plan: get(['plan']),
        metric_id: get(['metric_id','metric']),
        metric_name: get(['metric_name','metriclabel','name']),
        claim_scope: get(['claim_scope','scope']),
        denominator_n: num(get(['denominator_n','denominator','denom'], '0')),
        valid_n: num(get(['valid_n','valid'], '0')),
        invalid_n: num(get(['invalid_n','invalid'], '0')),
        null_n: num(get(['null_n','nulls','null'], '0')),
        multiple_n: num(get(['multiple_n','multiple'], '0')),
        valid_pct: pct(get(['valid_pct','valid_percent','pct_valid'], '')),
        threshold: pct(get(['threshold','min_valid_pct'], '')),
        pass_flag: (v => {
          const s = String(v).toLowerCase();
          return s === 'true' || s === '1' || s === 't' || s === 'yes';
        })(get(['pass_flag','pass'] , 'true')),
        denominator_desc: get(['denominator_desc','denominator_description']),
        tuva_last_run: get(['tuva_last_run','last_run'])
      };
      if ((out.valid_pct === null || out.valid_pct === undefined) && out.denominator_n > 0) {
        out.valid_pct = out.valid_n / out.denominator_n;
      }
      return out;
    }

    function parseCSVLine(line) {
      const result = []; let current = ''; let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i]; const next = i + 1 < line.length ? line[i+1] : '';
        if (ch === '"') {
          if (inQuotes && next === '"') { current += '"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if (ch === ',' && !inQuotes) {
          result.push(current); current = '';
        } else { current += ch; }
      }
      result.push(current);
      return result;
    }

    function populateDataSourceSelector() {
      const sel = byId('dataSource');
      sel.innerHTML = '';
      const keys = Array.from(byDataSource.keys()).sort();
      keys.forEach(k => {
        const opt = document.createElement('option');
        opt.value = k; opt.textContent = k || '—';
        sel.appendChild(opt);
      });
      if (keys.length) sel.value = keys[0];
    }

    function populateScopeSelector(ds=null) {
      const sel = byId('scopeSelect');
      if (!sel) return;
      sel.innerHTML = '';
      const rows = ds ? (byDataSource.get(ds) || []) : metrics;
      const scopes = Array.from(new Set(rows.map(m => m.claim_scope || ''))).filter(Boolean).sort();
      scopes.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s; opt.textContent = s;
        opt.selected = true; // default select all
        sel.appendChild(opt);
      });
    }

    function populatePayerPlanSelectors(ds=null) {
      const payerSel = byId('payerSelect');
      const planSel = byId('planSelect');
      const payerContainer = byId('payerContainer');
      const planContainer = byId('planContainer');
      if (!payerSel || !planSel) return;
      payerSel.innerHTML = '';
      planSel.innerHTML = '';
      const rows = ds ? (byDataSource.get(ds) || []) : metrics;
      const payers = Array.from(new Set(rows.map(m => m.payer || '').filter(Boolean))).sort();
      const plans = Array.from(new Set(rows.map(m => m.plan || '').filter(Boolean))).sort();
      payers.forEach(p => { const opt = document.createElement('option'); opt.value = p; opt.textContent = p; opt.selected = true; payerSel.appendChild(opt); });
      plans.forEach(p => { const opt = document.createElement('option'); opt.value = p; opt.textContent = p; opt.selected = true; planSel.appendChild(opt); });
      if (payerContainer) payerContainer.style.display = payers.length ? '' : 'none';
      if (planContainer) planContainer.style.display = plans.length ? '' : 'none';
    }

    function handleDataSourceChange() {
      const ds = byId('dataSource').value || '';
      populateScopeSelector(ds);
      populatePayerPlanSelectors(ds);
      render();
    }

    function getSelectedMulti(id) {
      const el = byId(id); if (!el) return [];
      return Array.from(el.options).filter(o => o.selected).map(o => o.value);
    }

    function getSelectedScopes() {
      const sel = byId('scopeSelect');
      if (!sel) return [];
      return Array.from(sel.options).filter(o => o.selected).map(o => o.value);
    }

    function setSort(key) {
      if (sortKey === key) {
        sortAsc = !sortAsc;
      } else {
        sortKey = key;
        // sensible defaults: for valid_pct sort ascending, for counts sort descending
        sortAsc = (key === 'valid_pct' || key === 'threshold' || key === 'metric');
      }
      updateSortIndicators();
      render();
    }

    function updateSortIndicators() {
      const keys = ['metric','valid_pct','denominator_n','valid_n','invalid_n','null_n','multiple_n','threshold','pass_flag'];
      keys.forEach(k => {
        const th = byId('th-'+k);
        if (!th) return;
        const base = th.getAttribute('data-label') || th.textContent.replace(/\s*[▲▼]$/, '');
        th.setAttribute('data-label', base);
        if (k === sortKey) {
          th.innerHTML = `${base}<span class="sort-indicator">${sortAsc ? '▲' : '▼'}</span>`;
        } else {
          th.innerHTML = base;
        }
      });
    }

    function getFilteredRows() {
      const ds = byId('dataSource').value || '';
      const search = (byId('searchMetric').value || '').toLowerCase();
      const rows = byDataSource.get(ds) || [];
      const scopes = getSelectedScopes();
      const selPayers = getSelectedMulti('payerSelect');
      const selPlans = getSelectedMulti('planSelect');
      return rows.filter(m =>
        (!search || (m.metric_name||'').toLowerCase().includes(search) || (m.metric_id||'').toLowerCase().includes(search)) &&
        (!scopes.length || scopes.includes(m.claim_scope || '')) &&
        (!selPayers.length || selPayers.includes(m.payer || '')) &&
        (!selPlans.length || selPlans.includes(m.plan || ''))
      );
    }

    function render() {
      filtered = getFilteredRows();
      if (viewMode === 'pivot') {
        renderPivot();
      } else {
        const cmp = (a,b) => {
          const nv = v => (v === null || v === undefined ? -Infinity : v);
          switch (sortKey) {
            case 'metric': {
              const an = (a.metric_name || a.metric_id || '').toLowerCase();
              const bn = (b.metric_name || b.metric_id || '').toLowerCase();
              return an.localeCompare(bn);
            }
            case 'valid_pct': return nv(a.valid_pct) - nv(b.valid_pct);
            case 'denominator_n': return nv(a.denominator_n) - nv(b.denominator_n);
            case 'valid_n': return nv(a.valid_n) - nv(b.valid_n);
            case 'invalid_n': return nv(a.invalid_n) - nv(b.invalid_n);
            case 'null_n': return nv(a.null_n) - nv(b.null_n);
            case 'multiple_n': return nv(a.multiple_n) - nv(b.multiple_n);
            case 'threshold': return nv(a.threshold) - nv(b.threshold);
            case 'pass_flag': return (a.pass_flag?1:0) - (b.pass_flag?1:0);
            default: return 0;
          }
        };
        filtered.sort((a,b) => sortAsc ? cmp(a,b) : -cmp(a,b));
        renderTable();
      }
    }

    function deriveTopGroup(scope) {
      const s = String(scope || '').toLowerCase();
      if (!s) return 'other';
      if (s === 'pharmacy') return 'pharmacy';
      if (s === 'eligibility') return 'eligibility';
      if (s.startsWith('institutional') || s.startsWith('professional') || s === 'medical') return 'medical';
      return s;
    }
    function deriveSubGroup(scope) {
      const s = String(scope || '').toLowerCase();
      if (s.startsWith('professional')) return 'professional';
      if (s.startsWith('institutional')) return 'institutional';
      if (s === 'medical') return 'medical (all)';
      return null;
    }

    function sumAgg(rows) {
      const agg = { denominator_n:0, valid_n:0, invalid_n:0, null_n:0, multiple_n:0 };
      rows.forEach(r => {
        agg.denominator_n += (r.denominator_n||0);
        agg.valid_n += (r.valid_n||0);
        agg.invalid_n += (r.invalid_n||0);
        agg.null_n += (r.null_n||0);
        agg.multiple_n += (r.multiple_n||0);
      });
      agg.valid_pct = agg.denominator_n > 0 ? agg.valid_n/agg.denominator_n : null;
      return agg;
    }

    function renderPivot() {
      const tbody = byId('tbody');
      tbody.innerHTML = '';
      // Group by top -> sub -> rows
      const groups = new Map();
      filtered.forEach(r => {
        const top = deriveTopGroup(r.claim_scope);
        const sub = deriveSubGroup(r.claim_scope);
        if (!groups.has(top)) groups.set(top, new Map());
        const subMap = groups.get(top);
        const subKey = sub || '__nosub__';
        if (!subMap.has(subKey)) subMap.set(subKey, []);
        subMap.get(subKey).push(r);
      });
      const orderedTop = ['medical','pharmacy','eligibility', ...Array.from(groups.keys()).filter(k => !['medical','pharmacy','eligibility'].includes(k)).sort()];
      const usedTop = orderedTop.filter(k => groups.has(k));
      usedTop.forEach(top => {
        const subMap = groups.get(top);
        // Top-level aggregate row
        const allRows = Array.from(subMap.values()).flat();
        const agg = sumAgg(allRows);
        const trTop = document.createElement('tr'); trTop.className = 'group-row';
        trTop.style.cursor = 'pointer';
        const caret = collapsedTop.has(top) ? '►' : '▼';
        const tdMetric = document.createElement('td'); tdMetric.innerHTML = `<span class="caret">${caret}</span>${top}`; trTop.appendChild(tdMetric);
        const tdPct = document.createElement('td'); tdPct.textContent = fmtPct(agg.valid_pct); trTop.appendChild(tdPct);
        const tdDen = document.createElement('td'); tdDen.textContent = fmtNum(agg.denominator_n); trTop.appendChild(tdDen);
        const tdValid = document.createElement('td'); tdValid.textContent = fmtNum(agg.valid_n); trTop.appendChild(tdValid);
        const tdInvalid = document.createElement('td'); tdInvalid.textContent = fmtNum(agg.invalid_n); trTop.appendChild(tdInvalid);
        const tdNull = document.createElement('td'); tdNull.textContent = fmtNum(agg.null_n); trTop.appendChild(tdNull);
        const tdMult = document.createElement('td'); tdMult.textContent = fmtNum(agg.multiple_n); trTop.appendChild(tdMult);
        const tdThr = document.createElement('td'); tdThr.textContent = '—'; trTop.appendChild(tdThr);
        const tdPass = document.createElement('td'); tdPass.textContent = ''; trTop.appendChild(tdPass);
        const tdSql = document.createElement('td'); tdSql.textContent = ''; trTop.appendChild(tdSql);
        trTop.onclick = () => { if (collapsedTop.has(top)) collapsedTop.delete(top); else collapsedTop.add(top); render(); };
        tbody.appendChild(trTop);

        if (!collapsedTop.has(top)) {
          // sub-groups
          for (const [subKey, arrRaw] of subMap.entries()) {
            const arr = [...arrRaw].sort((a,b) => (a.metric_name||a.metric_id||'').localeCompare(b.metric_name||b.metric_id||''));
            const showSub = subKey !== '__nosub__';
            const subLabel = subKey === '__nosub__' ? '—' : subKey;
            const subAgg = sumAgg(arr);
            const trSub = document.createElement('tr'); trSub.className = 'subgroup-row';
            if (showSub) trSub.style.cursor = 'pointer';
            const subId = `${top}::${subLabel}`;
            const caret2 = collapsedSub.has(subId) ? '►' : '▼';
            const tdM = document.createElement('td'); tdM.innerHTML = showSub ? `<span class="caret">${caret2}</span>${subLabel}` : `<span class="caret"></span>${subLabel}`; trSub.appendChild(tdM);
            const tdP = document.createElement('td'); tdP.textContent = fmtPct(subAgg.valid_pct); trSub.appendChild(tdP);
            const tdD = document.createElement('td'); tdD.textContent = fmtNum(subAgg.denominator_n); trSub.appendChild(tdD);
            const tdV = document.createElement('td'); tdV.textContent = fmtNum(subAgg.valid_n); trSub.appendChild(tdV);
            const tdI = document.createElement('td'); tdI.textContent = fmtNum(subAgg.invalid_n); trSub.appendChild(tdI);
            const tdN = document.createElement('td'); tdN.textContent = fmtNum(subAgg.null_n); trSub.appendChild(tdN);
            const tdMu = document.createElement('td'); tdMu.textContent = fmtNum(subAgg.multiple_n); trSub.appendChild(tdMu);
            const tdT = document.createElement('td'); tdT.textContent = '—'; trSub.appendChild(tdT);
            const tdPa = document.createElement('td'); tdPa.textContent = ''; trSub.appendChild(tdPa);
            const tdS = document.createElement('td'); tdS.textContent = ''; trSub.appendChild(tdS);
            if (showSub) trSub.onclick = () => { const k = `${top}::${subLabel}`; if (collapsedSub.has(k)) collapsedSub.delete(k); else collapsedSub.add(k); render(); };
            tbody.appendChild(trSub);

            if (!showSub || !collapsedSub.has(subId)) {
              // metric rows under this sub-group
              arr.forEach(row => {
                const idx = filtered.indexOf(row);
                const tr = document.createElement('tr');
                const tdMetric = document.createElement('td');
                tdMetric.innerHTML = `<div style="font-weight:600;">${row.metric_name || row.metric_id}</div><div class="small">${row.metric_id} · ${row.claim_scope||''}</div>`;
                tr.appendChild(tdMetric);

                const tdPct = document.createElement('td');
                const pctWrap = document.createElement('div'); pctWrap.style.display = 'flex'; pctWrap.style.alignItems = 'center'; pctWrap.style.gap = '8px';
                const pctText = document.createElement('span'); pctText.className = 'percent-text'; pctText.textContent = fmtPct(row.valid_pct);
                const bar = document.createElement('div'); bar.className = 'percent-bar'; bar.style.width = '120px';
                const fill = document.createElement('div'); fill.className = 'percent-fill'; fill.style.width = ((row.valid_pct||0)*100) + '%';
                const thr = typeof row.threshold === 'number' ? row.threshold : null;
                const pass = thr !== null ? (row.valid_pct ?? 0) >= thr : true;
                fill.style.background = pass ? '#16a34a' : '#dc2626';
                bar.appendChild(fill);
                pctWrap.appendChild(pctText); pctWrap.appendChild(bar);
                tdPct.appendChild(pctWrap); tr.appendChild(tdPct);

                const tdDen = document.createElement('td'); tdDen.textContent = fmtNum(row.denominator_n ?? 0); tr.appendChild(tdDen);
                const tdValid = document.createElement('td');
                const validCount2 = row.valid_n ?? 0;
                if (validCount2 > 0) {
                  const spanV2 = document.createElement('span');
                  spanV2.className = 'mini';
                  spanV2.style.textDecoration = 'underline';
                  spanV2.style.cursor = 'pointer';
                  spanV2.textContent = fmtNum(validCount2);
                  spanV2.onclick = (e) => openValuePopover(e.currentTarget, idx, 'valid');
                  tdValid.appendChild(spanV2);
                } else {
                  tdValid.textContent = fmtNum(validCount2);
                }
                tr.appendChild(tdValid);
        const tdInvalid = document.createElement('td');
        const invalidCount = row.invalid_n ?? 0;
        if (invalidCount > 0) {
          const span = document.createElement('span');
          span.className = 'mini';
          span.style.textDecoration = 'underline';
          span.style.cursor = 'pointer';
          span.textContent = fmtNum(invalidCount);
          span.onclick = (e) => openValuePopover(e.currentTarget, idx, 'invalid');
          tdInvalid.appendChild(span);
        } else {
          tdInvalid.textContent = fmtNum(invalidCount);
        }
        tr.appendChild(tdInvalid);
                const tdNull = document.createElement('td'); tdNull.textContent = fmtNum(row.null_n ?? 0); tr.appendChild(tdNull);
                const tdMult = document.createElement('td'); tdMult.textContent = fmtNum(row.multiple_n ?? 0); tr.appendChild(tdMult);
                const tdThr = document.createElement('td'); tdThr.textContent = thr !== null ? fmtPct(thr) : '—'; tr.appendChild(tdThr);
                const tdPass = document.createElement('td');
                const badge = document.createElement('span'); badge.className = 'badge ' + ((row.pass_flag ?? true) ? 'pass' : 'fail');
                badge.textContent = (row.pass_flag ?? true) ? 'PASS' : 'FAIL';
                tdPass.appendChild(badge); tr.appendChild(tdPass);
                const tdSql = document.createElement('td');
                const btn = document.createElement('button'); btn.textContent = 'View SQL'; btn.onclick = () => toggleSQL(idx, null);
                tdSql.appendChild(btn); tr.appendChild(tdSql);
                tbody.appendChild(tr);

                const trSql = document.createElement('tr'); trSql.id = `sql-${idx}`; trSql.style.display = 'none';
                const tdSqlFull = document.createElement('td'); tdSqlFull.colSpan = 10; tdSqlFull.className = 'sql';
                tdSqlFull.textContent = buildOffendersSQL(row, (byId('schemaPrefix')?.value||'data_quality').trim(), (byId('dataSource')?.value||'').trim());
                trSql.appendChild(tdSqlFull); tbody.appendChild(trSql);
              });
            }
          }
        }
      });
    }

    function fmtPct(x) { if (x === null || x === undefined) return '—'; return (x*100).toFixed(1) + '%'; }
    function fmtNum(x) { try { return Number(x||0).toLocaleString(); } catch { return String(x); } }

    function renderTable() {
      const tbody = byId('tbody');
      tbody.innerHTML = '';
      filtered.forEach((row, idx) => {
        const tr = document.createElement('tr');
        const tdMetric = document.createElement('td');
        tdMetric.innerHTML = `<div style="font-weight:600;">${row.metric_name || row.metric_id}</div><div class="small">${row.metric_id} · ${row.claim_scope||''}</div>`;
        tr.appendChild(tdMetric);

        const tdPct = document.createElement('td');
        const pctWrap = document.createElement('div'); pctWrap.style.display = 'flex'; pctWrap.style.alignItems = 'center'; pctWrap.style.gap = '8px';
        const pctText = document.createElement('span'); pctText.className = 'percent-text'; pctText.textContent = fmtPct(row.valid_pct);
        const bar = document.createElement('div'); bar.className = 'percent-bar'; bar.style.width = '120px';
        const fill = document.createElement('div'); fill.className = 'percent-fill'; fill.style.width = ((row.valid_pct||0)*100) + '%';
        // color based on threshold
        const thr = typeof row.threshold === 'number' ? row.threshold : null;
        const pass = thr !== null ? (row.valid_pct ?? 0) >= thr : true;
        fill.style.background = pass ? '#16a34a' : '#dc2626';
        bar.appendChild(fill);
        pctWrap.appendChild(pctText); pctWrap.appendChild(bar);
        tdPct.appendChild(pctWrap); tr.appendChild(tdPct);

        const tdDen = document.createElement('td'); tdDen.textContent = fmtNum(row.denominator_n ?? 0); tr.appendChild(tdDen);
        const tdValid = document.createElement('td');
        const validCount = row.valid_n ?? 0;
        if (validCount > 0) {
          const spanV = document.createElement('span');
          spanV.className = 'mini';
          spanV.style.textDecoration = 'underline';
          spanV.style.cursor = 'pointer';
          spanV.textContent = fmtNum(validCount);
          spanV.onclick = (e) => openValuePopover(e.currentTarget, idx, 'valid');
          tdValid.appendChild(spanV);
        } else {
          tdValid.textContent = fmtNum(validCount);
        }
        tr.appendChild(tdValid);
        const tdInvalid = document.createElement('td');
        const invalidCount = row.invalid_n ?? 0;
        if (invalidCount > 0) {
          const span = document.createElement('span');
          span.className = 'mini';
          span.style.textDecoration = 'underline';
          span.style.cursor = 'pointer';
          span.textContent = fmtNum(invalidCount);
                  span.onclick = (e) => openValuePopover(e.currentTarget, idx, 'invalid');
          tdInvalid.appendChild(span);
        } else {
          tdInvalid.textContent = fmtNum(invalidCount);
        }
        tr.appendChild(tdInvalid);
        const tdNull = document.createElement('td'); tdNull.textContent = fmtNum(row.null_n ?? 0); tr.appendChild(tdNull);
        const tdMult = document.createElement('td'); tdMult.textContent = fmtNum(row.multiple_n ?? 0); tr.appendChild(tdMult);

        const tdThr = document.createElement('td'); tdThr.textContent = thr !== null ? fmtPct(thr) : '—'; tr.appendChild(tdThr);

        const tdPass = document.createElement('td');
        const badge = document.createElement('span'); badge.className = 'badge ' + ((row.pass_flag ?? true) ? 'pass' : 'fail');
        badge.textContent = (row.pass_flag ?? true) ? 'PASS' : 'FAIL';
        tdPass.appendChild(badge); tr.appendChild(tdPass);
        const tdSql = document.createElement('td');
        const btn = document.createElement('button'); btn.textContent = 'View SQL'; btn.onclick = () => toggleSQL(idx, null);
        tdSql.appendChild(btn); tr.appendChild(tdSql);

        tbody.appendChild(tr);

        const trSql = document.createElement('tr'); trSql.id = `sql-${idx}`; trSql.style.display = 'none';
        const tdSqlFull = document.createElement('td'); tdSqlFull.colSpan = 10; tdSqlFull.className = 'sql';
        tdSqlFull.textContent = buildOffendersSQL(row, (byId('schemaPrefix')?.value||'data_quality').trim(), (byId('dataSource')?.value||'').trim());
        trSql.appendChild(tdSqlFull); tbody.appendChild(trSql);
      });
    }

    function toggleSQL(idx, bucket) {
      const tr = byId(`sql-${idx}`); if (!tr) return;
      const td = tr.querySelector('td');
      const ds = (byId('dataSource')?.value||'').trim();
      const row = filtered[idx];
      if (tr.style.display === 'none') {
        td.textContent = buildOffendersSQL(row, (byId('schemaPrefix')?.value||'data_quality').trim(), ds);
      }
      tr.style.display = tr.style.display === 'none' ? '' : 'none';
    }

    function openDetails(idx, bucket) {
      const ds = (byId('dataSource')?.value||'').trim();
      const row = filtered[idx];
      const tops = getTopValues(ds, row.payer, row.plan, row.metric_id, row.claim_scope, bucket) || [];
      const overlay = byId('detailsModal');
      const title = byId('modalTitle');
      const valuesHost = byId('modalTopValues');
      const sqlHost = byId('modalSQL');
      const sqlContainer = byId('modalSQLContainer');
      const copyBtn = byId('copySqlBtn');
      const toggleBtn = byId('toggleSqlBtn');
      title.textContent = `${row.metric_name || row.metric_id} — Top ${bucket} values`;
      // Build table or placeholder
      valuesHost.innerHTML = '';
      if (tops.length) {
        const table = document.createElement('table'); table.className = 'table';
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th style="width:60%;">value</th><th>description</th><th style="text-align:right;">count</th></tr>';
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        tops.slice(0, 200).forEach(r => {
          const tr = document.createElement('tr');
          const v = document.createElement('td'); v.textContent = r.value_code || '(blank)'; tr.appendChild(v);
          const d = document.createElement('td'); d.textContent = r.value_desc || ''; tr.appendChild(d);
          const c = document.createElement('td'); c.style.textAlign = 'right'; c.textContent = (r.frequency || 0).toLocaleString(); tr.appendChild(c);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        valuesHost.appendChild(table);
      } else {
        const msg = document.createElement('div'); msg.className = 'info';
        msg.textContent = `No preloaded ${bucket} values found. You can run the SQL below.`;
        valuesHost.appendChild(msg);
      }
      // SQL secondary if values present
      const sql = buildOffendersSQL(row, (byId('schemaPrefix')?.value||'data_quality').trim(), ds);
      sqlHost.textContent = sql;
      if (tops.length) {
        sqlContainer.style.display = 'none';
        toggleBtn.style.display = '';
        toggleBtn.textContent = 'Show SQL';
      } else {
        sqlContainer.style.display = '';
        toggleBtn.style.display = 'none';
      }
      copyBtn.onclick = () => { try { navigator.clipboard.writeText(sql); copyBtn.textContent = 'Copied'; setTimeout(() => copyBtn.textContent = 'Copy SQL', 1500);} catch(e) { alert('Copy failed'); } };
      toggleBtn.onclick = () => {
        if (sqlContainer.style.display === 'none') { sqlContainer.style.display = ''; toggleBtn.textContent = 'Hide SQL'; }
        else { sqlContainer.style.display = 'none'; toggleBtn.textContent = 'Show SQL'; }
      };
      overlay.style.display = 'flex';
    }

    // closeModal deprecated (modal removed)
    function closeModal() {}

    function buildOffendersSQL(row, schemaPrefix, selectedDataSource) {
      const map = {
        'claims:institutional_inpatient:DRG_CODE': { model:'data_quality__institutional_drg_code' },
        'claims:institutional:REVENUE_CENTER_CODE': { model:'data_quality__institutional_revenue_center_code' },
        'claims:institutional:BILL_TYPE_CODE': { model:'data_quality__institutional_bill_type_code' },
        'claims:professional:HCPCS_CODE': { model:'data_quality__claim_hcpcs_code', where:"claim_type = 'professional'" },
        'claims:institutional_outpatient:HCPCS_CODE': { model:'data_quality__claim_hcpcs_code', where:"claim_type = 'institutional' and substr(bill_type_code,1,2) != '11'" },
        'claims:professional:PLACE_OF_SERVICE_CODE': { model:'data_quality__professional_place_of_service_code' },
        'claims:medical:CLAIM_TYPE': { model:'data_quality__claim_claim_type' },
        'claims:professional:BILLING_NPI': { model:'data_quality__professional_billing_npi' },
        'claims:professional:RENDERING_NPI': { model:'data_quality__professional_rendering_npi' },
        'claims:professional:FACILITY_NPI': { model:'data_quality__professional_facility_npi' },
        'claims:institutional:BILLING_NPI': { model:'data_quality__institutional_billing_npi' },
        'claims:institutional:RENDERING_NPI': { model:'data_quality__institutional_rendering_npi' },
        'claims:institutional:FACILITY_NPI': { model:'data_quality__institutional_facility_npi' },
        'claims:professional:DIAGNOSIS_CODE_1': { model:'data_quality__professional_diagnosis_code_1' },
        'claims:professional:DIAGNOSIS_CODE_2': { model:'data_quality__professional_diagnosis_code_2' },
        'claims:professional:DIAGNOSIS_CODE_3': { model:'data_quality__professional_diagnosis_code_3' },
        'claims:institutional:DIAGNOSIS_CODE_1': { model:'data_quality__institutional_diagnosis_code_1' },
        'claims:institutional:DIAGNOSIS_CODE_2': { model:'data_quality__institutional_diagnosis_code_2' },
        'claims:institutional:DIAGNOSIS_CODE_3': { model:'data_quality__institutional_diagnosis_code_3' },
        'claims:institutional_inpatient:PROCEDURE_CODE_1': { model:'data_quality__institutional_procedure_code_1' },
        'claims:institutional_inpatient:PROCEDURE_CODE_2': { model:'data_quality__institutional_procedure_code_2' },
        'claims:institutional_inpatient:PROCEDURE_CODE_3': { model:'data_quality__institutional_procedure_code_3' },
        'claims:institutional:ADMIT_SOURCE_CODE': { model:'data_quality__institutional_admit_source_code' },
        'claims:institutional:ADMIT_TYPE_CODE': { model:'data_quality__institutional_admit_type_code' },
        'claims:institutional:DISCHARGE_DISPOSITION_CODE': { model:'data_quality__institutional_discharge_disposition_code' },
        'claims:pharmacy:NDC_CODE': { model:'data_quality__pharmacy_ndc_code' },
        'claims:pharmacy:DISPENSING_PROVIDER_NPI': { model:'data_quality__pharmacy_dispensing_provider_npi' },
        'claims:pharmacy:PRESCRIBING_PROVIDER_NPI': { model:'data_quality__pharmacy_prescribing_provider_npi' },
        'claims:eligibility:GENDER': { model:'data_quality__eligibility_gender' },
        'claims:eligibility:RACE': { model:'data_quality__eligibility_race' },
        'claims:eligibility:PAYER_TYPE': { model:'data_quality__eligibility_payer_type' },
        'claims:eligibility:MEDICARE_STATUS_CODE': { model:'data_quality__eligibility_medicare_status_code' },
        'claims:eligibility:DUAL_STATUS_CODE': { model:'data_quality__eligibility_dual_status_code' },
        'claims:eligibility:ORIGINAL_REASON_ENTITLEMENT_CODE': { model:'data_quality__eligibility_original_reason_entitlement_code' }
      };
      const entry = map[row.metric_id] || { model: null };
      const prefix = (schemaPrefix && schemaPrefix.trim()) ? schemaPrefix.trim() : 'data_quality';
      const model = entry.model || '<model_not_mapped>';
      const offenders = ["'invalid'", "'multiple'", "'null'"];
      const extraWhere = entry.where ? `\n  and ${entry.where}` : '';
      const ds = selectedDataSource || row.data_source || '';
      const sql = `-- Top offenders for ${row.metric_name || row.metric_id} (${row.claim_scope || ''})\n-- Update the schema prefix if needed (e.g., dev_brad.data_quality)\nwith base as (\n  select *\n  from ${prefix}.${model}\n  where bucket_name in (${offenders.join(', ')})\n    and data_source = '${ds.replace(/'/g, "''")}'${extraWhere}\n)\nselect drill_down_value, count(*) as offender_rows\nfrom base\nwhere drill_down_value is not null\ngroup by drill_down_value\norder by offender_rows desc\nlimit 100;\n\n-- Details\nselect data_source, source_date, table_name, drill_down_key, drill_down_value, field_name, bucket_name, invalid_reason, field_value\nfrom ${prefix}.${model}\nwhere bucket_name in (${offenders.join(', ')})\n  and data_source = '${ds.replace(/'/g, "''")}'${extraWhere}\norder by bucket_name desc, source_date desc\nlimit 1000;`;
      return sql;
    }

    function getTopValues(ds, payer, plan, metric_id, claim_scope, bucket_name) {
      if (!detailsIdx || !detailsIdx.size) return [];
      const exactKey = `${ds}||${payer||''}||${plan||''}||${metric_id}||${claim_scope||''}||${bucket_name}`;
      if (detailsIdx.has(exactKey)) return detailsIdx.get(exactKey);
      // Fallback: aggregate across payer/plan
      const all = [];
      for (const [key, arr] of detailsIdx.entries()) {
        const parts = key.split('||');
        if (parts.length !== 6) continue;
        const [kDs, , , kMetric, kScope, kBucket] = parts;
        if (kDs === ds && kMetric === metric_id && (kScope || '') === (claim_scope || '') && kBucket === bucket_name) {
          all.push(...arr);
        }
      }
      if (!all.length) return [];
      // Aggregate by value_code
      const map = new Map();
      all.forEach(r => {
        const k = r.value_code || '';
        const prev = map.get(k) || { value_code: r.value_code, value_desc: r.value_desc, frequency: 0 };
        prev.frequency += (r.frequency && !isNaN(r.frequency) ? r.frequency : 1);
        map.set(k, prev);
      });
      return Array.from(map.values()).sort((a,b) => b.frequency - a.frequency);
    }

    function loadSample() {
      // metrics sample
      const sampleMetrics = `"data_source","metric_id","metric_name","claim_scope","denominator_n","valid_n","invalid_n","null_n","multiple_n","valid_pct","threshold","pass_flag","denominator_desc","tuva_last_run"\n"payer_a","claims:institutional_inpatient:DRG_CODE","DRG Code (Inpatient)","institutional_inpatient",12000,11856,96,48,0,0.988,0.97,TRUE,"Institutional inpatient claims","2024-10-08"`;
      routeCSV(sampleMetrics);
      // details sample (pre-aggregated offenders)
      const sampleDetails = `data_source,metric_id,claim_scope,bucket_name,drill_down_value,frequency\npayer_a,claims:institutional_inpatient:DRG_CODE,institutional_inpatient,invalid,999,42\npayer_a,claims:institutional_inpatient:DRG_CODE,institutional_inpatient,invalid,000,25\npayer_a,claims:institutional_inpatient:DRG_CODE,institutional_inpatient,invalid,ABC,7`;
      routeCSV(sampleDetails);
      showInfo('Sample metrics and details loaded. Click an invalid count to see top values.');
    }
  </script>
</head>
<body>
  <div class="container">
    <div class="header">
      <img src="assets/tuva_logo.png" alt="Tuva" />
      <h1>Terminology Metrics</h1>
    </div>
    <div class="content">
      <div id="drop" class="upload" onclick="handlePick()" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
        <div style="font-weight:600;">Drop CSV here or click to choose</div>
        <div style="color:#64748b; font-size:0.95rem;">Metrics CSV columns: data_source, metric_id, metric_name, claim_scope, denominator_n, valid_n, invalid_n, null_n, multiple_n, valid_pct, threshold, pass_flag. Optionally also drop a Details CSV (e.g., data_source, metric_id, claim_scope, bucket_name, field_value/drill_down_value, frequency) to power Top offenders.</div>
        <input id="file" type="file" accept=".csv" multiple style="display:none" onchange="handleFile(event)" />
      </div>

      <div id="errorBox" class="error" style="display:none; margin: 12px 0;"></div>

      <div class="controls">
        <label>Schema Prefix</label>
        <input id="schemaPrefix" placeholder="e.g. dev_brad.data_quality" oninput="render()" />
        <label>data_source</label>
        <select id="dataSource" onchange="handleDataSourceChange()"></select>
        <label>View</label>
        <select id="viewSelect" onchange="viewMode = this.value; render()">
          <option value="table" selected>Table</option>
          <option value="pivot">Pivot</option>
        </select>
        <label>Search metric</label>
        <input id="searchMetric" placeholder="e.g. HCPCS or DRG" oninput="render()" />
        <span id="payerContainer"><label>payer</label>
        <select id="payerSelect" multiple size="5" onchange="render()"></select></span>
        <span id="planContainer"><label>plan</label>
        <select id="planSelect" multiple size="5" onchange="render()"></select></span>
        <label>Scope</label>
        <select id="scopeSelect" multiple size="5" onchange="render()"></select>
        <button class="primary" onclick="loadSample()">Load Sample Data</button>
      </div>

      <div class="grid">
        <div style="overflow:auto; max-height: 60vh; border:1px solid #e5e7eb; border-radius: 8px;">
          <table class="table">
            <thead>
              <tr>
                <th id="th-metric" class="sortable" onclick="setSort('metric')">metric</th>
                <th id="th-valid_pct" class="sortable" onclick="setSort('valid_pct')">valid %</th>
                <th id="th-denominator_n" class="sortable" onclick="setSort('denominator_n')">denominator</th>
                <th id="th-valid_n" class="sortable" onclick="setSort('valid_n')">valid</th>
                <th id="th-invalid_n" class="sortable" onclick="setSort('invalid_n')">invalid</th>
                <th id="th-null_n" class="sortable" onclick="setSort('null_n')">null</th>
                <th id="th-multiple_n" class="sortable" onclick="setSort('multiple_n')">multiple</th>
                <th id="th-threshold" class="sortable" onclick="setSort('threshold')">threshold</th>
                <th id="th-pass_flag" class="sortable" onclick="setSort('pass_flag')">status</th>
                <th>offenders</th>
              </tr>
            </thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>
      </div>

      <div class="footer">No PHI leaves the warehouse: export an aggregated CSV of metrics from your database and load it here. Set Schema Prefix to generate ready-to-run SQL snippets.</div>
    </div>
  </div>
  <!-- anchored popover is created dynamically -->
</body>
</html>
